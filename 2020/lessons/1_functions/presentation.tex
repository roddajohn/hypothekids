% Intended LaTeX compiler: pdflatex
\documentclass[11pt]{article}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{graphicx}
\usepackage{grffile}
\usepackage{longtable}
\usepackage{wrapfig}
\usepackage{rotating}
\usepackage[normalem]{ulem}
\usepackage{amsmath}
\usepackage{textcomp}
\usepackage{amssymb}
\usepackage{capt-of}
\usepackage{hyperref}
\author{Rodda John}
\date{06/22/2020}
\title{Functions}
\hypersetup{
 pdfauthor={Rodda John},
 pdftitle={Functions},
 pdfkeywords={},
 pdfsubject={},
 pdfcreator={Emacs 25.2.1 (Org mode N/A)}, 
 pdflang={English}}
\begin{document}

\maketitle

\section{Clerical Matters}
\label{sec:org4fe97df}
\begin{itemize}
\item Welcome!
\item We're a large group:
\begin{itemize}
\item Use Zoom well!
\item Chatting!
\item Raising hands!
\item Faster / slower!
\end{itemize}
\end{itemize}
\subsection{Schedule}
\label{sec:org03abe0a}
\begin{center}
\includegraphics[width=.9\linewidth]{./src/schedule.png}
\end{center}
\subsection{Today}
\label{sec:org168109e}
\begin{itemize}
\item Introduce you to writing your own functions
\item Learn about breaking projects down into manageable pieces
\item Start thinking algorithmically
\end{itemize}
\section{Functions}
\label{sec:orgb326434}
\begin{itemize}
\item What is a function?
\item A function is a procedure that execute code given certain inputs.
\item It must have
\begin{itemize}
\item A name
\item A definition (either local or in a library)
\end{itemize}
\item It may have
\begin{itemize}
\item Inputs (we will call these args, or arguments)
\item Outputs (we will call these return values)
\end{itemize}
\end{itemize}
\subsection{Why are these useful?}
\label{sec:org7aec906}
\begin{itemize}
\item Why are functions the most useful programming tool?
\item What are some use-cases?
\item How can we conceptualize a function?  How can we tell whether we ought make a function?
\end{itemize}
\section{Functions in Python}
\label{sec:org8d79af8}
\begin{itemize}
\item We need to learn how to do two things:
\begin{itemize}
\item Calling functions (executing them, using them)
\item Defining functions (making our own)
\end{itemize}
\end{itemize}
\subsection{Calling Functions}
\label{sec:org15c4f19}
\begin{verbatim}
print('Hello World!')
\end{verbatim}
\begin{verbatim}
len([1, 2, 3, 4, 5, 6])
\end{verbatim}
\begin{verbatim}
input()
\end{verbatim}
\begin{itemize}
\item How many \texttt{args} does each function have?
\item What is each functions output?
\end{itemize}
\subsection{Defining Functions}
\label{sec:orgb305998}
\subsubsection{Simple Function}
\label{sec:org0ed8678}
\begin{itemize}
\item This function:
\begin{itemize}
\item Accepts two numerical inputs
\item Returns the product
\end{itemize}
\end{itemize}
\begin{verbatim}
def product(x, y):
    return x * y
\end{verbatim}
\subsubsection{Sum of a list}
\label{sec:orgb73ddeb}
\begin{itemize}
\item This function:
\begin{itemize}
\item Accepts a list
\item Returns the sum of the elements of the list
\end{itemize}
\end{itemize}
\begin{verbatim}
def sum_of_list(l):
    to_return = 0  # Tracks the sum of the list

    i = 0  # Iterator to iterate through the list

    while i < len(l):
	to_return += l[i]
	i = i + 1

    return to_return
\end{verbatim}
\subsubsection{Generally}
\label{sec:orgcfab638}
\begin{itemize}
\item \texttt{def} opens a function definition block
\item A name is required, as well as \texttt{()} to denote the args
\item Take note of the \texttt{:}
\item As with \texttt{if} statements, and \texttt{while} loops, the code in the function is indented
\end{itemize}
\subsubsection{Thus}
\label{sec:org5f7f640}
\begin{verbatim}
def <name>(<args>):
--> code
--> (optional) return <to_return>
\end{verbatim}
\section{Let's Try it Out}
\label{sec:org1ea10d0}
\subsection{First Problem}
\label{sec:org8819638}
\begin{itemize}
\item Write a function (\texttt{sum}) that:
\begin{itemize}
\item Accepts two numerical inputs
\item Returns the sum
\end{itemize}
\item How can we test this function?
\begin{itemize}
\item What are the edge cases?
\end{itemize}
\end{itemize}
\subsubsection{First Problem Solution}
\label{sec:orge6e3086}
\begin{verbatim}
def sum(x, y):
    return x + y
\end{verbatim}
\begin{verbatim}
sum(1, 2)   # Should be 3
sum(4, -2)  # Should be 2
sum(4, 0)   # Should be 4
\end{verbatim}
\subsection{Second Problem}
\label{sec:org5fcca5e}
\begin{itemize}
\item Write a function (\texttt{product}) that:
\begin{itemize}
\item Accepts two numerical inputs
\item Returns the product
\item Does not use the \texttt{*} operator, and instead uses the \texttt{sum} function we defined above
\end{itemize}
\end{itemize}
\subsubsection{Second Problem Solution}
\label{sec:orge0838a2}
\begin{verbatim}
def product(x, y):
    to_return = 0

    iterator = 0

    while iterator < y:
	to_return = to_return + x

	iterator = iterator + 1

    return to_return
\end{verbatim}
\begin{verbatim}
product(1, 2)   # Should be 2
product(100, 2) # Should be 200
product(2, 100) # Should be 200
product(2, .5)  # Should be 1
\end{verbatim}
\subsection{Third Problem}
\label{sec:org975ca3c}
\begin{itemize}
\item Write a function(\texttt{divisible\_by}) that:
\begin{itemize}
\item Accepts two numerical inputs (\texttt{number}, and \texttt{factor})
\item Returns true if and only if \texttt{number} is evenly divisble by \texttt{factor}
\item Recall the \texttt{\%} operator, which returns the remainder of the first operand by the second
\end{itemize}
\end{itemize}
\subsubsection{Third Problem Solution}
\label{sec:org27974a7}
\begin{verbatim}
def divisible_by(number, factor):
    remainder = number % factor

    if remainder == 0:
	return True
    else:
	return False
\end{verbatim}
\begin{verbatim}
divisible_by(4, 2)  # Should be True
divisible_by(4, 1)  # Should be True
divisible_by(15, 3) # Should be True
divisible_by(15, 4) # Should be False
\end{verbatim}

\subsubsection{Or, even shorter}
\label{sec:org30ab6ae}
\begin{verbatim}
def divisible_by(number, factor):
    remainder = number % factor

    if remainder == 0:
	return True
    return False
\end{verbatim}
\subsubsection{Or, even shorter}
\label{sec:org0de9958}
\begin{verbatim}
def divisible_by(number, factor):
    return number % factor == 0
\end{verbatim}
\section{Algorithmic Speed}
\label{sec:org0da8a37}
big O notation

\begin{itemize}
\item Let's look at a worksheet problem
\end{itemize}
\begin{verbatim}
i = 0

while i < 100:
    if i % 2 == 0:
	print (i)

    i = i + 1
\end{verbatim}

\begin{verbatim}
i = 1

while i < 100:
    print (i)

    i = i + 2
\end{verbatim}
\subsection{Sorting Algorithms}
\label{sec:orge34e9d4}
\begin{itemize}
\item Let's talk through 4
\item Selection Sort
\item Insertion Sort
\item Bubble Sort
\item Quicksort
\end{itemize}
\subsubsection{Selection Sort}
\label{sec:org5623c67}
\begin{itemize}
\item The algorithm divides the list into two parts (sorted and unsorted).  It then finds the lowest element in the unsorted list, and places it in the ordered list.
\item Let's think through:
\begin{itemize}
\item Average Performance (comparisons and swaps)
\item Worst Case Performance (comparisons and swaps)
\item Best Case Performance (comparisons and swaps)
\end{itemize}
\end{itemize}
\subsubsection{Selection Sort Revealed}
\label{sec:org42daac5}
\begin{center}
\begin{tabular}{llll}
 & Worst & Best & Average\\
Comparisons & \(O(n^2)\) & \(O(n^2)\) & \(O(n^2)\)\\
Swaps & \(O(n)\) & \(O(n)\) & \(O(n)\)\\
\end{tabular}
\end{center}
\subsubsection{Insertion Sort}
\label{sec:org76936c5}
\begin{itemize}
\item The algorithm divides the list into two parts (sorted and unsorted).  It then takes the next element in the unsorted list and inserts it at the correct location in the sorted list.
\item Let's think through:
\begin{itemize}
\item Average Performance (comparisons and swaps)
\item Worst Case Performance (comparisons and swaps)
\item Best Case Performance (comparisons and swaps)
\end{itemize}
\end{itemize}
\subsubsection{Insertion Sort Revealed}
\label{sec:org3996292}
\begin{center}
\begin{tabular}{llll}
 & Worst & Best & Average\\
Comparison & \(O(n^2)\) & \(O(n)\) & \(O(n^2)\)\\
Swaps & \(O(n^2)\) & \(O(1)\) & \(O(n^2)\)\\
\end{tabular}
\end{center}
\subsubsection{Bubble Sort}
\label{sec:org9c0e961}
\begin{itemize}
\item The algorithm traverses an unsorted list and compares two adjacent elements and swaps them if necessary.
\item Let's think through:
\begin{itemize}
\item Average Performance (comparisons and swaps)
\item Worst Case Performance (comparisons and swaps)
\item Best Case Performance (comparisons and swaps)
\end{itemize}
\end{itemize}
\subsubsection{Bubble Sort Revealed}
\label{sec:org859214e}
\begin{center}
\begin{tabular}{llll}
 & Worst & Best & Average\\
Comparison & \(O(n^2)\) & \(O(n)\) & \(O(n^2)\)\\
Swaps & \(O(n^2)\) & \(O(1)\) & \(O(n^2)\)\\
\end{tabular}
\end{center}
\subsubsection{Quicksort}
\label{sec:org1ab29ab}
\begin{itemize}
\item The algorithm picks a random pivot value and places all values (still unsorted) below the pivot to the left of it, and the values above the pivot to the right of it.  It then recursively does the same thing on both lists.
\item Let's think through:
\begin{itemize}
\item Average Performance (comparisons and swaps)
\item Worst Case Performance (comparisons and swaps)
\item Best Case Performance (comparisons and swaps)
\end{itemize}
\item Recursive Function
\item Divide and concur
\end{itemize}
\subsubsection{Quicksort Revealed}
\label{sec:orgc9028f2}
\begin{center}
\begin{tabular}{llll}
 & Worst & Best & Average\\
Comparison & \(O(n^2)\) & \(O(n \log n)\) & \(O(n \log n)\)\\
Swaps & \(O(n^2)\) & \(O(n \log n)\) & \(O(n \log n)\)\\
\end{tabular}
\end{center}
\subsubsection{An Added Element}
\label{sec:org542f3d4}
Usually we often also care about how much storage we have to use.

Let's think through this.
\end{document}
